{"config":{"lang":["es"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Rasterizador LOVE2D","text":"<p>Bienvenido a la documentaci\u00f3n del Rasterizador LOVE2D, un motor de renderizado 3D por software implementado completamente en Lua usando el framework L\u00d6VE2D.</p> <p></p>"},{"location":"#que-es-este-proyecto","title":"\u00bfQu\u00e9 es este proyecto?","text":"<p>Este es un rasterizador 3D educativo que implementa desde cero los algoritmos fundamentales de gr\u00e1ficos 3D, sin usar aceleraci\u00f3n por hardware (OpenGL/DirectX). Es perfecto para entender c\u00f3mo funcionan realmente los motores 3D.</p>"},{"location":"#caracteristicas-implementadas","title":"Caracter\u00edsticas Implementadas","text":"<ul> <li>\ud83c\udfa8 Rasterizaci\u00f3n de tri\u00e1ngulos - Algoritmo edge-based con coordenadas baric\u00e9ntricas</li> <li>\ud83d\udcd0 Proyecci\u00f3n en perspectiva - Campo de visi\u00f3n (FOV) configurable</li> <li>\ud83d\udd04 Transformaciones 3D completas - Matrices de rotaci\u00f3n, traslaci\u00f3n</li> <li>\ud83c\udfae Sistema de c\u00e1mara FPS - Controles con mouse (yaw/pitch) y teclado (WASD)</li> <li>\ud83d\udcbe Z-buffer por software - Resoluci\u00f3n correcta de visibilidad</li> <li>\ud83c\udfaf Interpolaci\u00f3n perspective-correct - Profundidad interpolada correctamente</li> <li>\ud83d\udccf Triangulaci\u00f3n autom\u00e1tica - Convierte pol\u00edgonos en tri\u00e1ngulos (fan algorithm)</li> <li>\u26a1 Near plane clipping - Descarta geometr\u00eda inv\u00e1lida</li> <li>\ud83d\udcda C\u00f3digo completamente documentado - Con explicaciones matem\u00e1ticas detalladas</li> </ul>"},{"location":"#para-quien-es-esto","title":"\u00bfPara qui\u00e9n es esto?","text":"<ul> <li>\ud83c\udf93 Estudiantes de ciencias de la computaci\u00f3n aprendiendo gr\u00e1ficos 3D</li> <li>\ud83d\udcbb Programadores curiosos que quieren entender c\u00f3mo funcionan los motores 3D</li> <li>\ud83c\udfae Desarrolladores de L\u00d6VE2D experimentando con renderizado 3D</li> <li>\ud83e\uddee Entusiastas de las matem\u00e1ticas interesados en \u00e1lgebra lineal aplicada</li> <li>\ud83d\udc68\u200d\ud83c\udfeb Profesores buscando material educativo sobre computer graphics</li> </ul>"},{"location":"#inicio-rapido","title":"Inicio R\u00e1pido","text":""},{"location":"#requisitos","title":"Requisitos","text":"<ul> <li>L\u00d6VE2D 11.3 o superior</li> <li>Lua 5.1+</li> </ul>"},{"location":"#ejecutar","title":"Ejecutar","text":"<pre><code># Clonar el repositorio\ngit clone https://github.com/HambuP/Rasterizador_LOVE2D.git\ncd Rasterizador_LOVE2D\n\n# Ejecutar con L\u00d6VE\nlove lua/\n</code></pre>"},{"location":"#controles","title":"Controles","text":"<ul> <li>Mouse: Mover la c\u00e1mara (yaw/pitch)</li> <li>W/A/S/D: Moverse (adelante/izquierda/atr\u00e1s/derecha)</li> <li>ESC: Salir</li> </ul>"},{"location":"#que-aprenderas","title":"\u00bfQu\u00e9 Aprender\u00e1s?","text":"<p>A trav\u00e9s de esta documentaci\u00f3n completa, comprender\u00e1s:</p>"},{"location":"#1-fundamentos-matematicos","title":"1. Fundamentos Matem\u00e1ticos","text":"<ul> <li>\u2713 \u00c1lgebra lineal (vectores, matrices, producto punto)</li> <li>\u2713 Matrices de rotaci\u00f3n (Euler angles, composici\u00f3n)</li> <li>\u2713 Proyecci\u00f3n en perspectiva (FOV, frustum)</li> <li>\u2713 Coordenadas baric\u00e9ntricas (interpolaci\u00f3n)</li> <li>\u2713 Interpolaci\u00f3n perspective-correct</li> </ul>"},{"location":"#2-pipeline-de-graficos","title":"2. Pipeline de Gr\u00e1ficos","text":"<ul> <li>\u2713 Espacios de coordenadas (modelo \u2192 mundo \u2192 c\u00e1mara \u2192 pantalla)</li> <li>\u2713 Transformaciones 3D (rotaci\u00f3n, traslaci\u00f3n)</li> <li>\u2713 Proyecci\u00f3n y clipping</li> <li>\u2713 Rasterizaci\u00f3n de tri\u00e1ngulos</li> <li>\u2713 Z-buffering</li> </ul>"},{"location":"#3-implementacion-practica","title":"3. Implementaci\u00f3n Pr\u00e1ctica","text":"<ul> <li>\u2713 C\u00f3digo Lua optimizado y legible</li> <li>\u2713 Arquitectura del motor de rendering</li> <li>\u2713 T\u00e9cnicas de optimizaci\u00f3n</li> <li>\u2713 Debugging y profiling</li> </ul>"},{"location":"#documentacion-completa","title":"Documentaci\u00f3n Completa","text":""},{"location":"#guias-conceptuales","title":"\ud83d\udcd8 Gu\u00edas Conceptuales","text":"<ul> <li> <p>Conceptos Fundamentales</p> <p>Explicaci\u00f3n visual e intuitiva de c\u00f3mo funciona la rasterizaci\u00f3n 3D</p> <ul> <li>Pipeline de gr\u00e1ficos explicado</li> <li>Espacios de coordenadas</li> <li>Problema de visibilidad</li> <li>Z-buffering ilustrado</li> </ul> </li> <li> <p>Matem\u00e1ticas Completas</p> <p>Todas las f\u00f3rmulas con derivaciones paso a paso usando LaTeX</p> <ul> <li>\u00c1lgebra lineal b\u00e1sica</li> <li>Matrices de rotaci\u00f3n</li> <li>Proyecci\u00f3n en perspectiva</li> <li>Coordenadas baric\u00e9ntricas</li> <li>Interpolaci\u00f3n perspective-correct</li> </ul> </li> </ul>"},{"location":"#referencias-tecnicas","title":"\ud83d\udcd9 Referencias T\u00e9cnicas","text":"<ul> <li> <p>API de Vectores</p> <p>Documentaci\u00f3n completa del m\u00f3dulo <code>vectors.lua</code></p> <ul> <li>Operaciones vectoriales</li> <li>Multiplicaci\u00f3n de matrices</li> <li>Matrices de rotaci\u00f3n (X, Y, Z)</li> <li>Composici\u00f3n de rotaciones</li> <li>Ejemplos de uso</li> </ul> </li> <li> <p>C\u00f3digo Fuente</p> <p>C\u00f3digo completamente comentado en GitHub</p> <ul> <li><code>lua/vectors.lua</code> - \u00c1lgebra lineal</li> <li><code>lua/main.lua</code> - Motor de rendering</li> <li>Comentarios con f\u00f3rmulas matem\u00e1ticas</li> </ul> </li> </ul>"},{"location":"#arquitectura-del-proyecto","title":"Arquitectura del Proyecto","text":"<pre><code>Rasterizador_LOVE2D/\n\u251c\u2500\u2500 lua/\n\u2502   \u251c\u2500\u2500 main.lua          # Motor de rendering (576 l\u00edneas)\n\u2502   \u251c\u2500\u2500 vectors.lua       # \u00c1lgebra lineal (410 l\u00edneas)\n\u2502   \u2514\u2500\u2500 conf.lua          # Configuraci\u00f3n L\u00d6VE2D\n\u251c\u2500\u2500 docs/\n\u2502   \u251c\u2500\u2500 index.md          # Esta p\u00e1gina\n\u2502   \u251c\u2500\u2500 conceptos.md      # Gu\u00eda conceptual\n\u2502   \u251c\u2500\u2500 matematicas.md    # F\u00f3rmulas completas\n\u2502   \u2514\u2500\u2500 api_vectores.md   # Referencia API\n\u251c\u2500\u2500 screenshots/\n\u2502   \u2514\u2500\u2500 rasterizer.gif    # Demo animada\n\u251c\u2500\u2500 mkdocs.yml            # Configuraci\u00f3n docs\n\u251c\u2500\u2500 README.md             # Resumen del proyecto\n\u2514\u2500\u2500 LICENSE               # MIT License\n</code></pre>"},{"location":"#ejemplo-de-codigo","title":"Ejemplo de C\u00f3digo","text":""},{"location":"#rotar-y-proyectar-un-cubo","title":"Rotar y Proyectar un Cubo","text":"<pre><code>local vec = require(\"vectors\")\n\n-- Definir v\u00e9rtices de un cubo\nlocal cubo = {\n  {-1, -1, -1}, {1, -1, -1}, {1, 1, -1}, {-1, 1, -1},\n  {-1, -1,  1}, {1, -1,  1}, {1, 1,  1}, {-1, 1,  1}\n}\n\n-- Crear matriz de rotaci\u00f3n\nlocal angulo_x = math.rad(45)\nlocal angulo_y = math.rad(30)\nlocal R = vec.rotacion_completa(angulo_x, angulo_y, 0)\n\n-- Rotar todos los v\u00e9rtices\nlocal cubo_rotado = {}\nfor i, v in ipairs(cubo) do\n  cubo_rotado[i] = vec.mat3_vec(v, R)\nend\n\n-- Proyectar en pantalla (simplificado)\nlocal fov = 60\nlocal proyectados = proyectar_vertices(cubo_rotado, fov, 800, 600)\n</code></pre>"},{"location":"#pipeline-implementado","title":"Pipeline Implementado","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  Modelo 3D       \u2502  V\u00e9rtices + Caras\n\u2502  (5 figuras)     \u2502  - Piso (81 v\u00e9rtices)\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  - \u00c1rboles (4)\n         \u2502            - Personaje (1)\n         \u2193\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  Transformaci\u00f3n  \u2502  \u2022 Rotaci\u00f3n (matrices 3\u00d73)\n\u2502  Mundial         \u2502  \u2022 Traslaci\u00f3n\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2022 Cambio de base a c\u00e1mara\n         \u2193\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  Proyecci\u00f3n      \u2502  \u2022 FOV = 60\u00b0\n\u2502  Perspectiva     \u2502  \u2022 Near plane = 0.001\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2022 Divisi\u00f3n por Z\n         \u2193\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  Triangulaci\u00f3n   \u2502  \u2022 Triangular fan\n\u2502  y Clipping      \u2502  \u2022 Descarte de degenerados\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2022 Test de \u00e1rea &gt; \u03b5\n         \u2193\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  Rasterizaci\u00f3n   \u2502  \u2022 Edge function\n\u2502  con Z-Buffer    \u2502  \u2022 Coordenadas baric\u00e9ntricas\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2022 Interpolaci\u00f3n depth\n         \u2193            \u2022 Z-buffer test\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  Framebuffer     \u2502  Imagen final: 820\u00d7580\n\u2502  (Pantalla)      \u2502  Escalada a resoluci\u00f3n de ventana\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"#performance","title":"Performance","text":""},{"location":"#especificaciones-tecnicas","title":"Especificaciones T\u00e9cnicas","text":"Par\u00e1metro Valor Resoluci\u00f3n de rendering 820\u00d7580 (475,600 p\u00edxeles) Z-buffer 1 float por p\u00edxel (~1.8 MB) Escena de prueba ~290 v\u00e9rtices, ~200 caras Framerate 60 FPS (CPU moderna) Complejidad O(tri\u00e1ngulos \u00d7 p\u00edxeles_cubiertos)"},{"location":"#optimizaciones-implementadas","title":"Optimizaciones Implementadas","text":"<ul> <li>\u2713 Bounding box (evita testar p\u00edxeles fuera del tri\u00e1ngulo)</li> <li>\u2713 Near plane clipping (descarta geometr\u00eda inv\u00e1lida temprano)</li> <li>\u2713 Degeneracy test (evita procesar tri\u00e1ngulos colapsados)</li> <li>\u2713 Pre-c\u00e1lculo de 1/A (evita divisiones en inner loop)</li> </ul>"},{"location":"#limitaciones-por-diseno-educativo","title":"Limitaciones (por dise\u00f1o educativo)","text":"<ul> <li>\u274c Sin texturas (solo colores planos)</li> <li>\u274c Sin iluminaci\u00f3n din\u00e1mica (Phong/Blinn-Phong)</li> <li>\u274c Sin anti-aliasing</li> <li>\u274c Sin backface culling expl\u00edcito</li> <li>\u274c Sin far plane clipping</li> <li>\u274c Sin transparencia/blending</li> </ul> <p>Nota: Estas son oportunidades de aprendizaje. \u00a1Intenta implementarlas t\u00fa mismo!</p>"},{"location":"#comparacion-con-gpu-modernas","title":"Comparaci\u00f3n con GPU Modernas","text":"Caracter\u00edstica Este Rasterizador (CPU) GPU Moderna Tri\u00e1ngulos/frame ~1,000-10,000 Millones Paralelismo Secuencial Miles de cores Shaders No (colores fijos) S\u00ed (programables) Texturas No S\u00ed (aceleradas) Velocidad ~60 FPS 100+ FPS Claridad educativa \u2b50\u2b50\u2b50\u2b50\u2b50 \u2b50 (caja negra)"},{"location":"#contribuir","title":"Contribuir","text":"<p>Este es un proyecto educativo abierto. Las contribuciones son bienvenidas:</p>"},{"location":"#ideas-para-contribuir","title":"Ideas para Contribuir","text":"<ul> <li>\ud83d\udcdd Mejorar documentaci\u00f3n</li> <li>\ud83d\udc1b Reportar/arreglar bugs</li> <li>\u2728 Implementar nuevas features (texturas, iluminaci\u00f3n, etc.)</li> <li>\ud83c\udf93 Crear tutoriales adicionales</li> <li>\ud83c\udf0d Traducir documentaci\u00f3n</li> </ul>"},{"location":"#proceso","title":"Proceso","text":"<ol> <li>Fork el repositorio</li> <li>Crea una rama (<code>git checkout -b feature/mi-feature</code>)</li> <li>Commit tus cambios con mensajes descriptivos</li> <li>Push a tu fork (<code>git push origin feature/mi-feature</code>)</li> <li>Abre un Pull Request</li> </ol> <p>GitHub: https://github.com/HambuP/Rasterizador_LOVE2D</p>"},{"location":"#recursos-adicionales","title":"Recursos Adicionales","text":""},{"location":"#tutoriales-online","title":"Tutoriales Online","text":"<ul> <li>Scratchapixel: https://www.scratchapixel.com/</li> <li>LearnOpenGL: https://learnopengl.com/</li> <li>TinyRenderer: https://github.com/ssloy/tinyrenderer/wiki</li> </ul>"},{"location":"#libros-recomendados","title":"Libros Recomendados","text":"<ol> <li>\"Real-Time Rendering\" (4th Ed.) - Akenine-M\u00f6ller et al.</li> <li>\"Fundamentals of Computer Graphics\" (5th Ed.) - Marschner &amp; Shirley</li> <li>\"Computer Graphics: Principles and Practice\" (3rd Ed.) - Hughes et al.</li> </ol>"},{"location":"#videos","title":"Videos","text":"<ul> <li>3Blue1Brown: \u00c1lgebra lineal visual</li> <li>The Cherno: Serie de OpenGL</li> </ul>"},{"location":"#licencia","title":"Licencia","text":"<p>MIT License - Libre de usar, modificar y distribuir.</p> <p>Ver LICENSE para detalles.</p>"},{"location":"#comienza-ahora","title":"\u00a1Comienza Ahora!","text":"<ul> <li> <p>\ud83d\udcd6 Conceptos Fundamentales</p> <p>Entiende los conceptos b\u00e1sicos de rasterizaci\u00f3n con explicaciones visuales</p> </li> <li> <p>\ud83e\uddee Matem\u00e1ticas Completas</p> <p>Todas las f\u00f3rmulas con LaTeX y derivaciones paso a paso</p> </li> <li> <p>\u2699\ufe0f API de Vectores</p> <p>Referencia completa del m\u00f3dulo de \u00e1lgebra lineal</p> </li> <li> <p>\ud83d\udcbb C\u00f3digo Fuente</p> <p>Explora el c\u00f3digo completamente comentado en GitHub</p> </li> </ul> <p>\ud83d\udca1 Tip: Lee primero Conceptos Fundamentales para una introducci\u00f3n visual, luego explora Matem\u00e1ticas para los detalles t\u00e9cnicos.</p>"},{"location":"api_vectores/","title":"API: M\u00f3dulo de Vectores","text":"<p>Documentaci\u00f3n completa del m\u00f3dulo <code>vectors.lua</code> que implementa operaciones de \u00e1lgebra lineal para gr\u00e1ficos 3D.</p>"},{"location":"api_vectores/#importar-el-modulo","title":"Importar el M\u00f3dulo","text":"<pre><code>local vec = require(\"vectors\")\n</code></pre>"},{"location":"api_vectores/#operaciones-vectoriales","title":"Operaciones Vectoriales","text":""},{"location":"api_vectores/#veccrear","title":"<code>vec.crear()</code>","text":"<p>Crea un vector nulo (origen).</p> <p>Retorna: <code>{0, 0, 0}</code></p> <p>Ejemplo: <pre><code>local v = vec.crear()\n-- v = {0, 0, 0}\n</code></pre></p>"},{"location":"api_vectores/#vecdotvec1-vec2","title":"<code>vec.dot(vec1, vec2)</code>","text":"<p>Calcula el producto punto (dot product) entre dos vectores 3D.</p> <p>Par\u00e1metros:</p> <ul> <li><code>vec1</code>: Vector 3D <code>{x, y, z}</code></li> <li><code>vec2</code>: Vector 3D <code>{x, y, z}</code></li> </ul> <p>Retorna: N\u00famero (escalar)</p> <p>F\u00f3rmula:</p> \\[ \\mathbf{a} \\cdot \\mathbf{b} = a_x b_x + a_y b_y + a_z b_z \\] <p>Ejemplo: <pre><code>local a = {1, 0, 0}\nlocal b = {0, 1, 0}\nlocal resultado = vec.dot(a, b)\n-- resultado = 0 (vectores perpendiculares)\n\nlocal c = {3, 4, 0}\nlocal d = {1, 0, 0}\nlocal resultado2 = vec.dot(c, d)\n-- resultado2 = 3\n</code></pre></p> <p>Casos de uso:</p> <ul> <li>Calcular el \u00e1ngulo entre dos vectores: \\(\\cos(\\theta) = \\frac{\\mathbf{a} \\cdot \\mathbf{b}}{|\\mathbf{a}||\\mathbf{b}|}\\)</li> <li>Determinar si dos vectores son perpendiculares: \\(\\mathbf{a} \\cdot \\mathbf{b} = 0\\)</li> <li>Proyecci\u00f3n de un vector sobre otro</li> </ul>"},{"location":"api_vectores/#vecnormalizevec","title":"<code>vec.normalize(vec)</code>","text":"<p>Normaliza un vector a longitud unitaria (magnitud = 1).</p> <p>Par\u00e1metros:</p> <ul> <li><code>vec</code>: Vector 3D <code>{x, y, z}</code></li> </ul> <p>Retorna: Vector normalizado <code>{x', y', z'}</code> con \\(|\\mathbf{v}| = 1\\)</p> <p>F\u00f3rmula:</p> \\[ \\hat{\\mathbf{v}} = \\frac{\\mathbf{v}}{|\\mathbf{v}|} = \\frac{\\mathbf{v}}{\\sqrt{v_x^2 + v_y^2 + v_z^2}} \\] <p>Ejemplo: <pre><code>local v = {3, 4, 0}\nlocal vnorm = vec.normalize(v)\n-- vnorm = {0.6, 0.8, 0}\n-- Longitud: sqrt(0.6^2 + 0.8^2) = 1.0\n\nlocal cero = {0, 0, 0}\nlocal cero_norm = vec.normalize(cero)\n-- cero_norm = {0, 0, 0} (caso especial)\n</code></pre></p> <p>Nota: Si el vector es nulo (longitud 0), retorna <code>{0, 0, 0}</code> para evitar divisi\u00f3n por cero.</p>"},{"location":"api_vectores/#operaciones-de-matrices","title":"Operaciones de Matrices","text":""},{"location":"api_vectores/#vecmat3_mulmat1-mat2","title":"<code>vec.mat3_mul(mat1, mat2)</code>","text":"<p>Multiplica dos matrices 3\u00d73.</p> <p>Par\u00e1metros:</p> <ul> <li><code>mat1</code>: Matriz 3\u00d73 <code>{{fila1}, {fila2}, {fila3}}</code></li> <li><code>mat2</code>: Matriz 3\u00d73</li> </ul> <p>Retorna: Matriz 3\u00d73 resultado de \\(C = A \\times B\\)</p> <p>F\u00f3rmula:</p> \\[ C_{ij} = \\sum_{k=1}^{3} A_{ik} \\cdot B_{kj} \\] <p>Ejemplo: <pre><code>local A = {\n  {1, 0, 0},\n  {0, 1, 0},\n  {0, 0, 1}\n}  -- Matriz identidad\n\nlocal B = {\n  {2, 0, 0},\n  {0, 3, 0},\n  {0, 0, 4}\n}  -- Matriz escala\n\nlocal C = vec.mat3_mul(A, B)\n-- C = B (porque A es identidad)\n</code></pre></p> <p>\u26a0\ufe0f Importante: La multiplicaci\u00f3n de matrices NO es conmutativa: \\(A \\times B \\neq B \\times A\\) en general.</p>"},{"location":"api_vectores/#vecmat3_vecvec-mat","title":"<code>vec.mat3_vec(vec, mat)</code>","text":"<p>Multiplica una matriz 3\u00d73 por un vector 3D.</p> <p>Par\u00e1metros:</p> <ul> <li><code>vec</code>: Vector 3D <code>{x, y, z}</code></li> <li><code>mat</code>: Matriz 3\u00d73</li> </ul> <p>Retorna: Vector transformado \\(\\mathbf{v}' = M \\times \\mathbf{v}\\)</p> <p>F\u00f3rmula:</p> \\[ \\begin{pmatrix} v'_x \\\\ v'_y \\\\ v'_z \\end{pmatrix} = \\begin{pmatrix} m_{11} &amp; m_{12} &amp; m_{13} \\\\ m_{21} &amp; m_{22} &amp; m_{23} \\\\ m_{31} &amp; m_{32} &amp; m_{33} \\end{pmatrix} \\begin{pmatrix} v_x \\\\ v_y \\\\ v_z \\end{pmatrix} \\] <p>Ejemplo: <pre><code>-- Rotar vector (1, 0, 0) 90\u00b0 sobre eje Z\nlocal v = {1, 0, 0}\nlocal Rz = vec.rota_z(math.pi/2)  -- 90 grados\nlocal v_rotado = vec.mat3_vec(v, Rz)\n-- v_rotado \u2248 {0, 1, 0}\n</code></pre></p>"},{"location":"api_vectores/#matrices-de-rotacion","title":"Matrices de Rotaci\u00f3n","text":""},{"location":"api_vectores/#vecrota_xangle","title":"<code>vec.rota_x(angle)</code>","text":"<p>Genera matriz de rotaci\u00f3n alrededor del eje X (pitch).</p> <p>Par\u00e1metros:</p> <ul> <li><code>angle</code>: \u00c1ngulo en radianes</li> </ul> <p>Retorna: Matriz 3\u00d73 de rotaci\u00f3n \\(R_x(\\theta)\\)</p> <p>F\u00f3rmula:</p> \\[ R_x(\\theta) = \\begin{pmatrix} 1 &amp; 0 &amp; 0 \\\\ 0 &amp; \\cos\\theta &amp; -\\sin\\theta \\\\ 0 &amp; \\sin\\theta &amp; \\cos\\theta \\end{pmatrix} \\] <p>Ejemplo: <pre><code>-- Rotar 45 grados sobre eje X\nlocal Rx = vec.rota_x(math.pi/4)\nlocal v = {0, 1, 0}\nlocal v_rot = vec.mat3_vec(v, Rx)\n-- v_rot \u2248 {0, 0.707, 0.707}\n</code></pre></p> <p>Visualizaci\u00f3n:</p> <pre><code>Eje X (no cambia): \u2192\nPlano YZ rota:\n\n     Y              Y\n     \u2191       \u2192      \u2197\n     |              /\n     +--\u2192 Z    \u03b8   +--\u2192 Z\n</code></pre>"},{"location":"api_vectores/#vecrota_yangle","title":"<code>vec.rota_y(angle)</code>","text":"<p>Genera matriz de rotaci\u00f3n alrededor del eje Y (yaw).</p> <p>Par\u00e1metros:</p> <ul> <li><code>angle</code>: \u00c1ngulo en radianes</li> </ul> <p>Retorna: Matriz 3\u00d73 de rotaci\u00f3n \\(R_y(\\theta)\\)</p> <p>F\u00f3rmula:</p> \\[ R_y(\\theta) = \\begin{pmatrix} \\cos\\theta &amp; 0 &amp; \\sin\\theta \\\\ 0 &amp; 1 &amp; 0 \\\\ -\\sin\\theta &amp; 0 &amp; \\cos\\theta \\end{pmatrix} \\] <p>Ejemplo: <pre><code>-- Girar c\u00e1mara 30 grados a la derecha\nlocal yaw = vec.rota_y(math.rad(30))\n</code></pre></p> <p>Visualizaci\u00f3n:</p> <pre><code>Eje Y (no cambia): \u2191\nPlano XZ rota:\n\n  Z              Z\n  \u2191       \u2192      \u2197\n  |              /\n  +--\u2192 X    \u03b8   +--\u2192 X\n</code></pre>"},{"location":"api_vectores/#vecrota_zangle","title":"<code>vec.rota_z(angle)</code>","text":"<p>Genera matriz de rotaci\u00f3n alrededor del eje Z (roll).</p> <p>Par\u00e1metros:</p> <ul> <li><code>angle</code>: \u00c1ngulo en radianes</li> </ul> <p>Retorna: Matriz 3\u00d73 de rotaci\u00f3n \\(R_z(\\theta)\\)</p> <p>F\u00f3rmula:</p> \\[ R_z(\\theta) = \\begin{pmatrix} \\cos\\theta &amp; -\\sin\\theta &amp; 0 \\\\ \\sin\\theta &amp; \\cos\\theta &amp; 0 \\\\ 0 &amp; 0 &amp; 1 \\end{pmatrix} \\] <p>Ejemplo: <pre><code>-- Rotar sprite 2D 90 grados\nlocal Rz = vec.rota_z(math.pi/2)\n</code></pre></p> <p>Visualizaci\u00f3n:</p> <pre><code>Eje Z (no cambia): \u2299 (saliendo de la pantalla)\nPlano XY rota:\n\n  Y              Y\n  \u2191       \u2192      \u2197\n  |              /\n  +--\u2192 X    \u03b8   +--\u2192 X\n</code></pre>"},{"location":"api_vectores/#vecrotacion_completaanglex-angley-anglez","title":"<code>vec.rotacion_completa(anglex, angley, anglez)</code>","text":"<p>Compone rotaciones de Euler en el orden Z-Y-X.</p> <p>Par\u00e1metros:</p> <ul> <li><code>anglex</code>: \u00c1ngulo sobre X (pitch) en radianes</li> <li><code>angley</code>: \u00c1ngulo sobre Y (yaw) en radianes</li> <li><code>anglez</code>: \u00c1ngulo sobre Z (roll) en radianes</li> </ul> <p>Retorna: Matriz 3\u00d73 compuesta \\(R = R_z(\\gamma) \\times R_y(\\beta) \\times R_x(\\alpha)\\)</p> <p>F\u00f3rmula:</p> \\[ R_{\\text{total}} = R_z(\\gamma) \\cdot R_y(\\beta) \\cdot R_x(\\alpha) \\] <p>Orden de aplicaci\u00f3n (de derecha a izquierda):</p> <ol> <li>Primero rota sobre X (pitch)</li> <li>Luego rota sobre Y (yaw)</li> <li>Finalmente rota sobre Z (roll)</li> </ol> <p>Ejemplo: <pre><code>-- Orientaci\u00f3n completa de un objeto\nlocal pitch = math.rad(15)  -- Inclinar 15\u00b0 hacia arriba\nlocal yaw = math.rad(45)    -- Girar 45\u00b0 a la derecha\nlocal roll = math.rad(0)    -- Sin inclinaci\u00f3n lateral\n\nlocal R = vec.rotacion_completa(pitch, yaw, roll)\nlocal v = {1, 0, 0}\nlocal v_rot = vec.mat3_vec(v, R)\n</code></pre></p> <p>\u26a0\ufe0f Gimbal Lock:</p> <p>Las rotaciones de Euler sufren de \"gimbal lock\" cuando el \u00e1ngulo Y est\u00e1 cerca de \u00b190\u00b0. En ese caso, las rotaciones X y Z se vuelven dependientes.</p> <p>Alternativa: Usar cuaterniones para rotaciones libres de gimbal lock.</p>"},{"location":"api_vectores/#vectransposem","title":"<code>vec.transpose(M)</code>","text":"<p>Calcula la transpuesta de una matriz 3\u00d73.</p> <p>Par\u00e1metros:</p> <ul> <li><code>M</code>: Matriz 3\u00d73</li> </ul> <p>Retorna: Matriz transpuesta \\(M^T\\)</p> <p>F\u00f3rmula:</p> \\[ (M^T)_{ij} = M_{ji} \\] <p>La transpuesta intercambia filas por columnas:</p> \\[ \\begin{pmatrix} a &amp; b &amp; c \\\\ d &amp; e &amp; f \\\\ g &amp; h &amp; i \\end{pmatrix}^T = \\begin{pmatrix} a &amp; d &amp; g \\\\ b &amp; e &amp; h \\\\ c &amp; f &amp; i \\end{pmatrix} \\] <p>Ejemplo: <pre><code>local M = {\n  {1, 2, 3},\n  {4, 5, 6},\n  {7, 8, 9}\n}\n\nlocal MT = vec.transpose(M)\n-- MT = {\n--   {1, 4, 7},\n--   {2, 5, 8},\n--   {3, 6, 9}\n-- }\n</code></pre></p> <p>Uso especial: Para matrices de rotaci\u00f3n (ortonormales), la transpuesta es igual a la inversa:</p> \\[ R^T = R^{-1} \\] <p>Esto permite calcular la inversa de forma eficiente (\\(O(9)\\) en lugar de \\(O(27)\\)).</p> <p>Ejemplo de uso en c\u00e1mara: <pre><code>-- Crear matriz de rotaci\u00f3n de c\u00e1mara\nlocal Rcam = vec.mat3_mul(vec.rota_y(yaw), vec.rota_x(pitch))\n\n-- Calcular inversa (para transformar mundo \u2192 c\u00e1mara)\nlocal Rcam_inv = vec.transpose(Rcam)  -- Eficiente!\n</code></pre></p>"},{"location":"api_vectores/#convenciones","title":"Convenciones","text":""},{"location":"api_vectores/#sistema-de-coordenadas","title":"Sistema de Coordenadas","text":"<p>El rasterizador usa un sistema de coordenadas mano derecha (right-handed):</p> <pre><code>      Y (arriba)\n      \u2191\n      |\n      |\n      +-----\u2192 X (derecha)\n     /\n    /\n   Z (hacia la c\u00e1mara)\n</code></pre> <p>Regla de la mano derecha:</p> <ul> <li>Dedo \u00edndice: +X</li> <li>Dedo medio: +Y</li> <li>Pulgar: +Z</li> </ul>"},{"location":"api_vectores/#angulos","title":"\u00c1ngulos","text":"<ul> <li>Todos los \u00e1ngulos est\u00e1n en radianes</li> <li>Para convertir de grados: <code>radianes = math.rad(grados)</code></li> <li>Para convertir a grados: <code>grados = math.deg(radianes)</code></li> </ul> <p>Conversiones comunes:</p> Grados Radianes Valor aproximado 0\u00b0 0 0 30\u00b0 \u03c0/6 0.524 45\u00b0 \u03c0/4 0.785 60\u00b0 \u03c0/3 1.047 90\u00b0 \u03c0/2 1.571 180\u00b0 \u03c0 3.142 360\u00b0 2\u03c0 6.283"},{"location":"api_vectores/#representacion-de-datos","title":"Representaci\u00f3n de Datos","text":"<p>Vectores: <pre><code>local v = {x, y, z}\n-- Acceso:\nlocal x = v[1]\nlocal y = v[2]\nlocal z = v[3]\n</code></pre></p> <p>Matrices 3\u00d73: <pre><code>local M = {\n  {m11, m12, m13},  -- Fila 1\n  {m21, m22, m23},  -- Fila 2\n  {m31, m32, m33}   -- Fila 3\n}\n\n-- Acceso:\nlocal elemento = M[fila][columna]\n</code></pre></p>"},{"location":"api_vectores/#ejemplos-completos","title":"Ejemplos Completos","text":""},{"location":"api_vectores/#ejemplo-1-rotar-un-cubo","title":"Ejemplo 1: Rotar un Cubo","text":"<pre><code>local vec = require(\"vectors\")\n\n-- Definir v\u00e9rtices de un cubo\nlocal vertices = {\n  {-1, -1, -1}, {1, -1, -1}, {1, 1, -1}, {-1, 1, -1},\n  {-1, -1,  1}, {1, -1,  1}, {1, 1,  1}, {-1, 1,  1}\n}\n\n-- Crear matriz de rotaci\u00f3n\nlocal angulo = math.rad(45)\nlocal R = vec.rotacion_completa(angulo, angulo, 0)\n\n-- Rotar todos los v\u00e9rtices\nlocal vertices_rotados = {}\nfor i, v in ipairs(vertices) do\n  vertices_rotados[i] = vec.mat3_vec(v, R)\nend\n</code></pre>"},{"location":"api_vectores/#ejemplo-2-orientar-objeto-hacia-un-punto","title":"Ejemplo 2: Orientar Objeto hacia un Punto","text":"<pre><code>local vec = require(\"vectors\")\n\n-- Posici\u00f3n del objeto y del objetivo\nlocal pos_objeto = {0, 0, 0}\nlocal pos_objetivo = {10, 5, 3}\n\n-- Vector direcci\u00f3n\nlocal direccion = {\n  pos_objetivo[1] - pos_objeto[1],\n  pos_objetivo[2] - pos_objeto[2],\n  pos_objetivo[3] - pos_objeto[3]\n}\n\n-- Normalizar para obtener vector unitario\nlocal dir_norm = vec.normalize(direccion)\n\n-- Calcular \u00e1ngulos (simplificado)\nlocal yaw = math.atan2(dir_norm[1], dir_norm[3])\nlocal pitch = math.asin(-dir_norm[2])\n\n-- Crear matriz de rotaci\u00f3n\nlocal R = vec.rotacion_completa(pitch, yaw, 0)\n</code></pre>"},{"location":"api_vectores/#ejemplo-3-crear-sistema-de-coordenadas-local","title":"Ejemplo 3: Crear Sistema de Coordenadas Local","text":"<pre><code>local vec = require(\"vectors\")\n\n-- Definir orientaci\u00f3n\nlocal forward = {0, 0, 1}  -- Hacia adelante\nlocal up = {0, 1, 0}       -- Arriba\n\n-- Calcular vector derecha (cross product manual)\nlocal function cross(a, b)\n  return {\n    a[2]*b[3] - a[3]*b[2],\n    a[3]*b[1] - a[1]*b[3],\n    a[1]*b[2] - a[2]*b[1]\n  }\nend\n\nlocal right = vec.normalize(cross(forward, up))\nlocal up_corrected = vec.normalize(cross(right, forward))\n\n-- Construir matriz de cambio de base\nlocal M = {\n  {right[1], right[2], right[3]},\n  {up_corrected[1], up_corrected[2], up_corrected[3]},\n  {-forward[1], -forward[2], -forward[3]}\n}\n</code></pre>"},{"location":"api_vectores/#performance","title":"Performance","text":""},{"location":"api_vectores/#complejidad-computacional","title":"Complejidad Computacional","text":"Operaci\u00f3n Complejidad Operaciones <code>dot</code> O(3) 3 mult + 2 sum <code>normalize</code> O(6) 3 cuad + 1 sqrt + 3 div <code>mat3_vec</code> O(9) 9 mult + 6 sum <code>mat3_mul</code> O(27) 27 mult + 18 sum <code>rota_x/y/z</code> O(2) 1 cos + 1 sin <code>transpose</code> O(9) 9 asignaciones"},{"location":"api_vectores/#optimizaciones","title":"Optimizaciones","text":"<ol> <li>Pre-calcular rotaciones: Si una matriz de rotaci\u00f3n se usa m\u00faltiples veces, calcularla una sola vez.</li> </ol> <pre><code>-- Lento (recalcula cada frame)\nfor i = 1, 1000 do\n  local R = vec.rota_y(angle)\n  -- usar R...\nend\n\n-- R\u00e1pido (calcula una vez)\nlocal R = vec.rota_y(angle)\nfor i = 1, 1000 do\n  -- usar R...\nend\n</code></pre> <ol> <li> <p>Evitar normalizaci\u00f3n innecesaria: Si un vector ya est\u00e1 normalizado, no normalizarlo de nuevo.</p> </li> <li> <p>Usar transpuesta en lugar de inversa: Para matrices ortonormales.</p> </li> </ol>"},{"location":"api_vectores/#referencias","title":"Referencias","text":"<ul> <li>Implementaci\u00f3n: <code>lua/vectors.lua</code></li> <li>Matem\u00e1ticas: <code>docs/matematicas.md</code></li> <li>Ejemplos de uso: <code>lua/main.lua</code></li> </ul> <p>\ud83d\udcdd Nota: Este m\u00f3dulo est\u00e1 optimizado para claridad educativa. Para aplicaciones de producci\u00f3n, considerar usar bibliotecas especializadas como CPML o glm-lua.</p>"},{"location":"conceptos/","title":"Conceptos Fundamentales de Rasterizaci\u00f3n 3D","text":"<p>Esta gu\u00eda explica los conceptos clave detr\u00e1s del rasterizador desde una perspectiva conceptual y pr\u00e1ctica.</p>"},{"location":"conceptos/#tabla-de-contenidos","title":"Tabla de Contenidos","text":"<ol> <li>\u00bfQu\u00e9 es la Rasterizaci\u00f3n?</li> <li>Pipeline de Gr\u00e1ficos 3D</li> <li>Espacios de Coordenadas</li> <li>El Problema de Visibilidad</li> <li>Proyecci\u00f3n en Perspectiva</li> <li>C\u00f3mo Funciona el Z-Buffer</li> </ol>"},{"location":"conceptos/#que-es-la-rasterizacion","title":"\u00bfQu\u00e9 es la Rasterizaci\u00f3n?","text":"<p>La rasterizaci\u00f3n es el proceso de convertir geometr\u00eda 3D (tri\u00e1ngulos, l\u00edneas, puntos) en p\u00edxeles 2D en una pantalla.</p>"},{"location":"conceptos/#analogia-visual","title":"Analog\u00eda Visual","text":"<p>Imagina que tienes un modelo 3D de una casa y quieres dibujarlo en un lienzo 2D:</p> <pre><code>Modelo 3D              Rasterizaci\u00f3n           Imagen 2D\n   \ud83d\udce6                       \u2192                    \ud83d\uddbc\ufe0f\n(geometr\u00eda)                                  (p\u00edxeles)\n</code></pre> <p>El proceso:</p> <ol> <li>Entrada: Lista de tri\u00e1ngulos en 3D</li> <li>Proceso: Determinar qu\u00e9 p\u00edxeles cubre cada tri\u00e1ngulo</li> <li>Salida: Imagen 2D con p\u00edxeles coloreados</li> </ol>"},{"location":"conceptos/#rasterizacion-vs-ray-tracing","title":"Rasterizaci\u00f3n vs Ray Tracing","text":"Aspecto Rasterizaci\u00f3n Ray Tracing Enfoque Para cada tri\u00e1ngulo \u2192 encontrar p\u00edxeles Para cada p\u00edxel \u2192 encontrar tri\u00e1ngulo Velocidad R\u00e1pida (tiempo real) Lenta (offline) Calidad Buena Fotorrealista Iluminaci\u00f3n Aproximada F\u00edsicamente correcta Reflejos Dif\u00edcil Natural Uso Videojuegos, apps interactivas Pel\u00edculas, renders est\u00e1ticos"},{"location":"conceptos/#pipeline-de-graficos-3d","title":"Pipeline de Gr\u00e1ficos 3D","text":"<p>El pipeline de gr\u00e1ficos es el flujo de transformaciones que convierte un modelo 3D en una imagen 2D.</p>"},{"location":"conceptos/#pipeline-completo","title":"Pipeline Completo","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 1. ESPACIO DE MODELO (Model Space)                             \u2502\n\u2502    \u2022 V\u00e9rtices definidos en coordenadas locales del objeto      \u2502\n\u2502    \u2022 Ejemplo: cubo centrado en (0,0,0) con lado = 2           \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                           \u2502\n                           \u2502 Transformaci\u00f3n de Modelo\n                           \u2502 (Rotaci\u00f3n + Traslaci\u00f3n + Escala)\n                           \u2193\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 2. ESPACIO MUNDIAL (World Space)                               \u2502\n\u2502    \u2022 V\u00e9rtices en el sistema de coordenadas del mundo           \u2502\n\u2502    \u2022 Ejemplo: cubo en posici\u00f3n (10, 5, 3) en el mundo         \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                           \u2502\n                           \u2502 Transformaci\u00f3n de Vista\n                           \u2502 (Traslaci\u00f3n + Rotaci\u00f3n de c\u00e1mara)\n                           \u2193\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 3. ESPACIO DE C\u00c1MARA (View/Camera Space)                       \u2502\n\u2502    \u2022 V\u00e9rtices relativos a la c\u00e1mara                            \u2502\n\u2502    \u2022 C\u00e1mara est\u00e1 en origen, mirando hacia -Z                   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                           \u2502\n                           \u2502 Proyecci\u00f3n en Perspectiva\n                           \u2502 (Divisi\u00f3n por Z)\n                           \u2193\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 4. ESPACIO DE CLIP (Clip Space)                                \u2502\n\u2502    \u2022 Coordenadas normalizadas (-1 a +1)                        \u2502\n\u2502    \u2022 Clipping de geometr\u00eda fuera de view frustum               \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                           \u2502\n                           \u2502 Conversi\u00f3n a Pantalla\n                           \u2502 (Escala + Offset)\n                           \u2193\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 5. ESPACIO DE PANTALLA (Screen Space)                          \u2502\n\u2502    \u2022 Coordenadas en p\u00edxeles (x, y)                             \u2502\n\u2502    \u2022 Ejemplo: (400, 300) en una pantalla 800\u00d7600              \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                           \u2502\n                           \u2502 Rasterizaci\u00f3n\n                           \u2502 (Convertir tri\u00e1ngulos a p\u00edxeles)\n                           \u2193\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 6. FRAGMENTOS (Fragments)                                       \u2502\n\u2502    \u2022 P\u00edxeles candidatos con atributos interpolados             \u2502\n\u2502    \u2022 Cada fragmento tiene: posici\u00f3n, color, profundidad        \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                           \u2502\n                           \u2502 Z-Buffer Test\n                           \u2502 (Determinar visibilidad)\n                           \u2193\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 7. FRAMEBUFFER (Imagen Final)                                  \u2502\n\u2502    \u2022 P\u00edxeles finales en pantalla                                \u2502\n\u2502    \u2022 Solo los fragmentos visibles sobreviven                    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"conceptos/#ejemplo-numerico","title":"Ejemplo Num\u00e9rico","text":"<p>Seguir un v\u00e9rtice a trav\u00e9s del pipeline:</p> <pre><code>-- 1. ESPACIO DE MODELO\nv_model = {1, 0, 0}  -- Esquina derecha de un cubo\n\n-- 2. ESPACIO MUNDIAL (rotar 45\u00b0 + trasladar)\n-- Rotaci\u00f3n Y de 45\u00b0:\nv_world = {0.707, 0, 0.707}\n-- Traslaci\u00f3n:\nv_world = {0.707, 0, 0.707 + 5} = {0.707, 0, 5.707}\n\n-- 3. ESPACIO DE C\u00c1MARA (c\u00e1mara en z=-2, sin rotaci\u00f3n)\nv_camera = {0.707, 0, 5.707 - (-2)} = {0.707, 0, 7.707}\n\n-- 4. PROYECCI\u00d3N (FOV=60\u00b0, pantalla 800\u00d7600)\nfx = 502  -- distancia focal\nx_screen = 502 \u00d7 (0.707 / 7.707) + 400 = 446\ny_screen = 300  -- (y=0 \u2192 centro)\n-- Resultado: p\u00edxel (446, 300)\n</code></pre>"},{"location":"conceptos/#espacios-de-coordenadas","title":"Espacios de Coordenadas","text":""},{"location":"conceptos/#sistema-de-coordenadas-de-la-camara","title":"Sistema de Coordenadas de la C\u00e1mara","text":"<pre><code>        Y (Arriba)\n        \u2191\n        |\n        |\n        +-------\u2192 X (Derecha)\n       /\n      /\n     Z (Atr\u00e1s)\n\nLa c\u00e1mara mira hacia -Z\n</code></pre> <p>Convenciones:</p> <ul> <li>+X: Derecha de la c\u00e1mara</li> <li>+Y: Arriba de la c\u00e1mara</li> <li>+Z: Atr\u00e1s de la c\u00e1mara (\u26a0\ufe0f c\u00e1mara mira hacia -Z)</li> </ul>"},{"location":"conceptos/#view-frustum","title":"View Frustum","text":"<p>El frustum es la pir\u00e1mide truncada que define qu\u00e9 geometr\u00eda es visible:</p> <pre><code>         Near Plane\n            |   \\\n            |    \\\n            |     \\  \u2190 FOV\n      ------+------\\\n     /      |       \\\n    /       |        \\\n   /        |         \\\n  /____________________|\n         Far Plane\n</code></pre> <p>Par\u00e1metros:</p> <ul> <li>Near plane: Distancia m\u00ednima visible (ej: 0.1)</li> <li>Far plane: Distancia m\u00e1xima visible (ej: 1000)</li> <li>FOV: Campo de visi\u00f3n (ej: 60\u00b0)</li> <li>Aspect ratio: Relaci\u00f3n ancho/alto (ej: 16/9)</li> </ul> <p>Geometr\u00eda fuera del frustum se descarta (clipping).</p>"},{"location":"conceptos/#el-problema-de-visibilidad","title":"El Problema de Visibilidad","text":""},{"location":"conceptos/#que-triangulo-esta-adelante","title":"\u00bfQu\u00e9 Tri\u00e1ngulo Est\u00e1 Adelante?","text":"<p>Cuando m\u00faltiples tri\u00e1ngulos cubren el mismo p\u00edxel, \u00bfcu\u00e1l dibujar?</p> <pre><code>Escena 3D (vista lateral):\n\n  C\u00e1mara     T1 (cerca)   T2 (lejos)\n    \ud83d\udc41\ufe0f --------\ud83d\udd34----------\ud83d\udd35------\n              z=2         z=5\n</code></pre> <p>Soluciones:</p>"},{"location":"conceptos/#1-painters-algorithm-ordenar-por-profundidad","title":"1. Painter's Algorithm (Ordenar por Profundidad)","text":"<pre><code>1. Ordenar tri\u00e1ngulos de atr\u00e1s \u2192 adelante\n2. Dibujar en ese orden\n</code></pre> <p>Problema: No funciona con intersecciones c\u00edclicas:</p> <pre><code>    A\n   /|\\\n  / | \\\n /  B  \\\n/  / \\  \\\n\\ /   \\ /\n C-----+\n</code></pre> <p>\u00bfOrden correcto? A\u2192B\u2192C\u2192A... \u274c (ciclo infinito)</p>"},{"location":"conceptos/#2-z-buffer-buffer-de-profundidad","title":"2. Z-Buffer (Buffer de Profundidad)","text":"<pre><code>Para cada p\u00edxel:\n  zbuffer[p\u00edxel] = \u221e  (inicialmente)\n\nPara cada tri\u00e1ngulo:\n  Para cada p\u00edxel cubierto:\n    if z &lt; zbuffer[p\u00edxel]:\n      dibujar p\u00edxel\n      zbuffer[p\u00edxel] = z\n</code></pre> <p>Ventaja: Funciona siempre, sin importar el orden. \u2713</p>"},{"location":"conceptos/#proyeccion-en-perspectiva-explicada","title":"Proyecci\u00f3n en Perspectiva Explicada","text":""},{"location":"conceptos/#la-camara-pinhole","title":"La C\u00e1mara Pinhole","text":"<pre><code>Mundo 3D              Plano de proyecci\u00f3n       Imagen\n\n    O                        |                    o\n   /|\\                       |                   /|\\\n  / | \\        \u2192             |        \u2192          | |\n     P                       |                    p\n   (alto)                    |                 (bajo)\n</code></pre> <p>Intuici\u00f3n: Objetos lejanos se proyectan m\u00e1s cerca del centro.</p>"},{"location":"conceptos/#formula-visual","title":"F\u00f3rmula Visual","text":"<p>Para un punto \\((x, y, z)\\) en espacio de c\u00e1mara:</p> \\[ x_{\\text{proyectado}} = \\frac{x}{z} \\quad \\text{(dividir por profundidad)} \\] <p>Ejemplo:</p> <pre><code>Dos puntos a la misma altura (y=1):\n  \u2022 P1 = (1, 1, 2)  \u2192 x_proj = 1/2 = 0.5\n  \u2022 P2 = (1, 1, 4)  \u2192 x_proj = 1/4 = 0.25\n\nP2 est\u00e1 m\u00e1s lejos, as\u00ed que se proyecta m\u00e1s cerca del centro.\n</code></pre>"},{"location":"conceptos/#campo-de-vision-fov","title":"Campo de Visi\u00f3n (FOV)","text":"<p>El FOV determina cu\u00e1nto del mundo es visible:</p> <pre><code>FOV peque\u00f1o (30\u00b0):          FOV grande (90\u00b0):\n      |  |                       |      |\n      |  |                       |      |\n    --|--|--                   --|------|--\n      |  |                       |      |\n   (zoom in)                  (zoom out)\n</code></pre> <p>Relaci\u00f3n:</p> <ul> <li>FOV alto \u2192 Ve m\u00e1s del mundo \u2192 Objetos parecen peque\u00f1os</li> <li>FOV bajo \u2192 Ve menos del mundo \u2192 Objetos parecen grandes (efecto zoom)</li> </ul>"},{"location":"conceptos/#como-funciona-el-z-buffer","title":"C\u00f3mo Funciona el Z-Buffer","text":""},{"location":"conceptos/#visualizacion-paso-a-paso","title":"Visualizaci\u00f3n Paso a Paso","text":"<p>Frame inicial:</p> <pre><code>Color buffer:          Z-buffer:\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510           \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2502           \u2502\u221e\u221e\u221e\u221e\u221e\u221e\u221e\u221e\u221e\u2502\n\u2502\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2502           \u2502\u221e\u221e\u221e\u221e\u221e\u221e\u221e\u221e\u221e\u2502\n\u2502\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2502           \u2502\u221e\u221e\u221e\u221e\u221e\u221e\u221e\u221e\u221e\u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518           \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n(negro)               (infinito)\n</code></pre> <p>Dibujar tri\u00e1ngulo rojo (z=5):</p> <pre><code>Color buffer:          Z-buffer:\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510           \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502\u2591\u2591\ud83d\udd34\ud83d\udd34\ud83d\udd34\u2591\u2591\u2502           \u2502\u221e\u221e555\u221e\u221e\u221e\u2502\n\u2502\u2591\ud83d\udd34\ud83d\udd34\ud83d\udd34\ud83d\udd34\u2591\u2502           \u2502\u221e5555555\u221e\u2502\n\u2502\u2591\u2591\ud83d\udd34\ud83d\udd34\ud83d\udd34\u2591\u2591\u2502           \u2502\u221e\u221e555\u221e\u221e\u221e\u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518           \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Dibujar tri\u00e1ngulo azul (z=3, m\u00e1s cerca):</p> <pre><code>                         Comparaci\u00f3n Z:\nColor buffer:              5 vs 3\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510           \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502\u2591\ud83d\udd35\ud83d\udd35\ud83d\udd35\ud83d\udd34\u2591\u2502    3&lt;5    \u2502\u221e3335533\u221e\u2502\n\u2502\ud83d\udd35\ud83d\udd35\ud83d\udd35\ud83d\udd35\ud83d\udd35\ud83d\udd34\u2502   (azul    \u25023333335\u221e\u2502\n\u2502\u2591\ud83d\udd35\ud83d\udd35\ud83d\udd35\ud83d\udd34\u2591\u2591\u2502   gana)   \u2502\u221e3335533\u221e\u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518           \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Resultado: El tri\u00e1ngulo azul (m\u00e1s cerca) oculta parcialmente al rojo.</p>"},{"location":"conceptos/#pseudocodigo-detallado","title":"Pseudoc\u00f3digo Detallado","text":"<pre><code>function rasterizar_tri\u00e1ngulo(T):\n  para cada p\u00edxel (x, y) dentro de T:\n    # 1. Interpolar profundidad\n    z = interpolar_profundidad(T, x, y)\n\n    # 2. Probar z-buffer\n    if z &lt; zbuffer[x, y]:\n      # 3. Este fragmento est\u00e1 m\u00e1s cerca\n      zbuffer[x, y] = z\n      color[x, y] = color_tri\u00e1ngulo\n\n      # 4. (opcional) Calcular iluminaci\u00f3n\n      # color[x, y] = iluminar(T, x, y)\n</code></pre>"},{"location":"conceptos/#precision-y-z-fighting","title":"Precisi\u00f3n y Z-Fighting","text":"<p>Problema: Cuando dos superficies est\u00e1n muy cerca, pueden \"pelear\" por p\u00edxeles:</p> <pre><code>Frame 1:  \ud83d\udd34\ud83d\udd34\ud83d\udd35\ud83d\udd34\ud83d\udd34\nFrame 2:  \ud83d\udd34\ud83d\udd35\ud83d\udd35\ud83d\udd35\ud83d\udd34  \u2190 Parpadeo!\nFrame 3:  \ud83d\udd34\ud83d\udd34\ud83d\udd35\ud83d\udd34\ud83d\udd34\n</code></pre> <p>Causas:</p> <ol> <li>Precisi\u00f3n limitada de float (32 bits)</li> <li>Near/far planes muy separados</li> <li>Superficies coplanares</li> </ol> <p>Soluciones:</p> <ul> <li>Separar ligeramente las superficies</li> <li>Ajustar near/far planes</li> <li>Usar mayor precisi\u00f3n (64 bits)</li> <li>Polygon offset</li> </ul>"},{"location":"conceptos/#coordenadas-baricentricas-explicadas","title":"Coordenadas Baric\u00e9ntricas Explicadas","text":""},{"location":"conceptos/#que-son","title":"\u00bfQu\u00e9 Son?","text":"<p>Las coordenadas baric\u00e9ntricas expresan la posici\u00f3n de un punto dentro de un tri\u00e1ngulo como pesos de los v\u00e9rtices.</p>"},{"location":"conceptos/#visualizacion","title":"Visualizaci\u00f3n","text":"<pre><code>      v1\n      /\\\n     /  \\\n  w1/    \\w2\n   / P\u2022   \\\n  /  w3    \\\n /__________\\\nv3          v2\n\nP = w1\u00d7v1 + w2\u00d7v2 + w3\u00d7v3\ndonde w1 + w2 + w3 = 1\n</code></pre> <p>Interpretaci\u00f3n:</p> <ul> <li>\\(w_1 = 1, w_2 = 0, w_3 = 0\\) \u2192 P est\u00e1 en v1</li> <li>\\(w_1 = 0.5, w_2 = 0.5, w_3 = 0\\) \u2192 P est\u00e1 en el punto medio de v1-v2</li> <li>\\(w_1 = w_2 = w_3 = 1/3\\) \u2192 P est\u00e1 en el centroide del tri\u00e1ngulo</li> </ul>"},{"location":"conceptos/#uso-en-interpolacion","title":"Uso en Interpolaci\u00f3n","text":"<p>Para interpolar cualquier atributo (color, textura, normal):</p> <pre><code>-- V\u00e9rtices con colores\nv1 = {pos={0,1,0}, color={1,0,0}}  -- Rojo\nv2 = {pos={-1,-1,0}, color={0,1,0}}  -- Verde\nv3 = {pos={1,-1,0}, color={0,0,1}}  -- Azul\n\n-- Punto P con coordenadas baric\u00e9ntricas\nw1, w2, w3 = 0.5, 0.25, 0.25\n\n-- Color interpolado\ncolor_P = {\n  r = 0.5\u00d71 + 0.25\u00d70 + 0.25\u00d70 = 0.5,\n  g = 0.5\u00d70 + 0.25\u00d71 + 0.25\u00d70 = 0.25,\n  b = 0.5\u00d70 + 0.25\u00d70 + 0.25\u00d71 = 0.25\n}\n-- Resultado: Naranja (mezcla de rojo dominante)\n</code></pre>"},{"location":"conceptos/#optimizaciones-y-tecnicas-avanzadas","title":"Optimizaciones y T\u00e9cnicas Avanzadas","text":""},{"location":"conceptos/#bounding-box","title":"Bounding Box","text":"<p>En lugar de testar todos los p\u00edxeles de la pantalla:</p> <pre><code>\u274c Na\u00efve:\nProbar 800\u00d7600 = 480,000 p\u00edxeles por tri\u00e1ngulo\n\n\u2713 Bounding box:\n1. Calcular rect\u00e1ngulo m\u00ednimo que contiene el tri\u00e1ngulo\n2. Solo probar p\u00edxeles dentro del rect\u00e1ngulo\n3. T\u00edpicamente 10-100\u00d7 m\u00e1s r\u00e1pido\n</code></pre>"},{"location":"conceptos/#backface-culling","title":"Backface Culling","text":"<p>No dibujar tri\u00e1ngulos que miran hacia atr\u00e1s:</p> <pre><code>    Frente        Atr\u00e1s\n     /\\            /\\\n    /  \\          /  \\\n   /    \\        /    \\\n  --------      --------\n    \ud83d\udc41\ufe0f             \ud83d\udc41\ufe0f\n  (dibujar)     (descartar)\n</code></pre> <p>Test: Si el producto punto entre la normal y la direcci\u00f3n de vista es negativo, descartar.</p>"},{"location":"conceptos/#early-z-test","title":"Early Z-Test","text":"<p>Probar z-buffer antes de calcular color:</p> <pre><code>Para cada p\u00edxel:\n  z = interpolar_profundidad()\n\n  if z &gt; zbuffer[p\u00edxel]:\n    return  # Este p\u00edxel est\u00e1 oculto, skip!\n\n  # Solo calcular color si es visible\n  color = calcular_iluminacion()\n  ...\n</code></pre> <p>Ahorro: Evita c\u00e1lculos costosos de shading para p\u00edxeles ocultos.</p>"},{"location":"conceptos/#comparacion-con-gpu-modernas","title":"Comparaci\u00f3n con GPU Modernas","text":"<p>Este rasterizador implementa los conceptos fundamentales que usan las GPU, pero de forma simplificada:</p> Concepto Rasterizador (CPU) GPU Moderna Paralelismo Secuencial Miles de cores Shaders Colores planos Programables (GLSL) Texturas No implementado Hardware acelerado Iluminaci\u00f3n No Shaders personalizados Anti-aliasing No MSAA, FXAA, TAA Performance ~1000 tris/frame Millones/frame <p>Ventaja educativa: Este c\u00f3digo es comprensible y muestra claramente c\u00f3mo funcionan los algoritmos.</p>"},{"location":"conceptos/#proximos-pasos","title":"Pr\u00f3ximos Pasos","text":"<p>Despu\u00e9s de entender estos conceptos, puedes explorar:</p> <ol> <li>Matem\u00e1ticas Detalladas: F\u00f3rmulas y demostraciones completas</li> <li>API de Vectores: C\u00f3mo usar las funciones de \u00e1lgebra lineal</li> <li>C\u00f3digo Fuente: Implementaci\u00f3n completa</li> </ol>"},{"location":"conceptos/#referencias-y-recursos","title":"Referencias y Recursos","text":""},{"location":"conceptos/#tutoriales-online","title":"Tutoriales Online","text":"<ul> <li>Scratchapixel: https://www.scratchapixel.com/</li> <li>Explicaciones matem\u00e1ticas detalladas</li> <li>LearnOpenGL: https://learnopengl.com/</li> <li>Tutoriales de OpenGL (conceptos similares)</li> <li>TinyRenderer: https://github.com/ssloy/tinyrenderer/wiki</li> <li>Implementar un rasterizador desde cero (C++)</li> </ul>"},{"location":"conceptos/#libros-recomendados","title":"Libros Recomendados","text":"<ol> <li>\"Real-Time Rendering\" (4th Ed.) - Akenine-M\u00f6ller et al.</li> <li>La biblia de gr\u00e1ficos en tiempo real</li> <li>\"Fundamentals of Computer Graphics\" (5th Ed.) - Marschner &amp; Shirley</li> <li>Excelente introducci\u00f3n acad\u00e9mica</li> <li>\"Computer Graphics: Principles and Practice\" (3rd Ed.) - Hughes et al.</li> <li>Cl\u00e1sico completo de CG</li> </ol>"},{"location":"conceptos/#videos","title":"Videos","text":"<ul> <li>3Blue1Brown: \u00c1lgebra lineal visual</li> <li>https://www.youtube.com/c/3blue1brown</li> <li>The Cherno: Serie de OpenGL</li> <li>https://www.youtube.com/c/TheChernoProject</li> </ul> <p>\ud83d\udca1 Experimento: Intenta modificar el c\u00f3digo para agregar nuevas features (texturas, iluminaci\u00f3n, etc.). La mejor forma de aprender es implementando!</p>"},{"location":"matematicas/","title":"Fundamentos Matem\u00e1ticos del Rasterizador","text":"<p>Este documento explica en detalle las matem\u00e1ticas detr\u00e1s de cada componente del rasterizador 3D.</p>"},{"location":"matematicas/#tabla-de-contenidos","title":"Tabla de Contenidos","text":"<ol> <li>\u00c1lgebra Lineal B\u00e1sica</li> <li>Matrices de Rotaci\u00f3n</li> <li>Proyecci\u00f3n en Perspectiva</li> <li>Coordenadas Baric\u00e9ntricas</li> <li>Interpolaci\u00f3n Perspective-Correct</li> <li>Z-Buffering</li> </ol>"},{"location":"matematicas/#algebra-lineal-basica","title":"\u00c1lgebra Lineal B\u00e1sica","text":""},{"location":"matematicas/#vectores-3d","title":"Vectores 3D","text":"<p>Un vector en \\(\\mathbb{R}^3\\) se representa como:</p> \\[ \\mathbf{v} = \\begin{pmatrix} x \\\\ y \\\\ z \\end{pmatrix} \\]"},{"location":"matematicas/#producto-punto-dot-product","title":"Producto Punto (Dot Product)","text":"<p>El producto punto de dos vectores \\(\\mathbf{a}\\) y \\(\\mathbf{b}\\) es:</p> \\[ \\mathbf{a} \\cdot \\mathbf{b} = a_x b_x + a_y b_y + a_z b_z = |\\mathbf{a}| |\\mathbf{b}| \\cos(\\theta) \\] <p>donde \\(\\theta\\) es el \u00e1ngulo entre los vectores.</p> <p>Propiedades importantes:</p> <ul> <li>Si \\(\\mathbf{a} \\cdot \\mathbf{b} = 0\\), los vectores son perpendiculares</li> <li>Si \\(\\mathbf{a} \\cdot \\mathbf{b} &gt; 0\\), el \u00e1ngulo es agudo (\\(&lt; 90\u00b0\\))</li> <li>Si \\(\\mathbf{a} \\cdot \\mathbf{b} &lt; 0\\), el \u00e1ngulo es obtuso (\\(&gt; 90\u00b0\\))</li> </ul>"},{"location":"matematicas/#normalizacion","title":"Normalizaci\u00f3n","text":"<p>La normalizaci\u00f3n de un vector lo convierte a longitud unitaria:</p> \\[ \\hat{\\mathbf{v}} = \\frac{\\mathbf{v}}{|\\mathbf{v}|} = \\frac{\\mathbf{v}}{\\sqrt{v_x^2 + v_y^2 + v_z^2}} \\]"},{"location":"matematicas/#matrices-33","title":"Matrices 3\u00d73","text":"<p>Una matriz \\(3 \\times 3\\) se representa como:</p> \\[ M = \\begin{pmatrix} m_{11} &amp; m_{12} &amp; m_{13} \\\\ m_{21} &amp; m_{22} &amp; m_{23} \\\\ m_{31} &amp; m_{32} &amp; m_{33} \\end{pmatrix} \\]"},{"location":"matematicas/#multiplicacion-matriz-vector","title":"Multiplicaci\u00f3n Matriz-Vector","text":"\\[ M \\mathbf{v} = \\begin{pmatrix} m_{11}v_x + m_{12}v_y + m_{13}v_z \\\\ m_{21}v_x + m_{22}v_y + m_{23}v_z \\\\ m_{31}v_x + m_{32}v_y + m_{33}v_z \\end{pmatrix} \\] <p>Cada componente del resultado es el producto punto de una fila de \\(M\\) con \\(\\mathbf{v}\\).</p>"},{"location":"matematicas/#multiplicacion-de-matrices","title":"Multiplicaci\u00f3n de Matrices","text":"\\[ (AB)_{ij} = \\sum_{k=1}^{3} A_{ik} B_{kj} \\] <p>Importante: La multiplicaci\u00f3n de matrices NO es conmutativa: \\(AB \\neq BA\\) en general.</p>"},{"location":"matematicas/#matrices-de-rotacion","title":"Matrices de Rotaci\u00f3n","text":"<p>Las matrices de rotaci\u00f3n son transformaciones que rotan vectores alrededor de ejes en el espacio 3D.</p>"},{"location":"matematicas/#propiedades-de-matrices-de-rotacion","title":"Propiedades de Matrices de Rotaci\u00f3n","text":"<p>Todas las matrices de rotaci\u00f3n son ortonormales, lo que significa:</p> <ol> <li>Sus columnas (y filas) son vectores unitarios mutuamente perpendiculares</li> <li>\\(R^T R = R R^T = I\\) (la transpuesta es la inversa)</li> <li>\\(\\det(R) = 1\\) (preservan orientaci\u00f3n)</li> <li>Preservan longitudes: \\(|R\\mathbf{v}| = |\\mathbf{v}|\\)</li> </ol>"},{"location":"matematicas/#rotacion-sobre-el-eje-x-pitch","title":"Rotaci\u00f3n sobre el Eje X (Pitch)","text":"<p>Rota en el plano YZ, manteniendo X constante:</p> \\[ R_x(\\theta) = \\begin{pmatrix} 1 &amp; 0 &amp; 0 \\\\ 0 &amp; \\cos\\theta &amp; -\\sin\\theta \\\\ 0 &amp; \\sin\\theta &amp; \\cos\\theta \\end{pmatrix} \\] <p>Derivaci\u00f3n: Para rotar un punto \\((x, y, z)\\):</p> <ul> <li>\\(x' = x\\) (eje de rotaci\u00f3n no cambia)</li> <li>\\(y' = y \\cos\\theta - z \\sin\\theta\\)</li> <li>\\(z' = y \\sin\\theta + z \\cos\\theta\\)</li> </ul>"},{"location":"matematicas/#rotacion-sobre-el-eje-y-yaw","title":"Rotaci\u00f3n sobre el Eje Y (Yaw)","text":"<p>Rota en el plano XZ, manteniendo Y constante:</p> \\[ R_y(\\theta) = \\begin{pmatrix} \\cos\\theta &amp; 0 &amp; \\sin\\theta \\\\ 0 &amp; 1 &amp; 0 \\\\ -\\sin\\theta &amp; 0 &amp; \\cos\\theta \\end{pmatrix} \\] <p>Nota: El signo negativo en \\(R_y\\) se debe a la convenci\u00f3n de mano derecha (right-handed).</p>"},{"location":"matematicas/#rotacion-sobre-el-eje-z-roll","title":"Rotaci\u00f3n sobre el Eje Z (Roll)","text":"<p>Rota en el plano XY, manteniendo Z constante:</p> \\[ R_z(\\theta) = \\begin{pmatrix} \\cos\\theta &amp; -\\sin\\theta &amp; 0 \\\\ \\sin\\theta &amp; \\cos\\theta &amp; 0 \\\\ 0 &amp; 0 &amp; 1 \\end{pmatrix} \\] <p>Esta es la rotaci\u00f3n 2D cl\u00e1sica extendida a 3D.</p>"},{"location":"matematicas/#composicion-de-rotaciones-angulos-de-euler","title":"Composici\u00f3n de Rotaciones (\u00c1ngulos de Euler)","text":"<p>Para aplicar m\u00faltiples rotaciones, se multiplican las matrices. El orden importa:</p> \\[ R_{\\text{total}} = R_z(\\gamma) \\cdot R_y(\\beta) \\cdot R_x(\\alpha) \\] <p>Este orden (ZYX) significa que se aplica primero la rotaci\u00f3n X, luego Y, luego Z.</p> <p>Ejemplo: <pre><code>Para rotar un vector v:\n  v' = R_z(R_y(R_x(v)))\n</code></pre></p>"},{"location":"matematicas/#gimbal-lock","title":"Gimbal Lock","text":"<p>\u26a0\ufe0f Advertencia: Las rotaciones de Euler sufren de \"gimbal lock\" cuando el \u00e1ngulo Y est\u00e1 cerca de \\(\\pm 90\u00b0\\). En ese caso, las rotaciones X y Z se vuelven dependientes, perdiendo un grado de libertad.</p> <p>Soluci\u00f3n alternativa: Usar cuaterniones para rotaciones libres de gimbal lock.</p>"},{"location":"matematicas/#proyeccion-en-perspectiva","title":"Proyecci\u00f3n en Perspectiva","text":"<p>La proyecci\u00f3n en perspectiva convierte coordenadas 3D en coordenadas 2D de pantalla, simulando c\u00f3mo objetos lejanos se ven m\u00e1s peque\u00f1os.</p>"},{"location":"matematicas/#modelo-de-camara-pinhole","title":"Modelo de C\u00e1mara Pinhole","text":"<p>El modelo b\u00e1sico es una c\u00e1mara \"pinhole\" (agujero de alfiler):</p> <pre><code>        Objeto 3D (x,y,z)\n             \u2193\n        Plano focal\n             \u2193\n      Centro de proyecci\u00f3n\n             \u2193\n        Imagen 2D\n</code></pre>"},{"location":"matematicas/#formulas-de-proyeccion","title":"F\u00f3rmulas de Proyecci\u00f3n","text":"<p>Para un punto \\(\\mathbf{p} = (x, y, z)\\) en espacio de c\u00e1mara:</p> \\[ \\begin{aligned} x_{\\text{ndc}} &amp;= \\frac{x}{z} \\\\ y_{\\text{ndc}} &amp;= \\frac{y}{z} \\end{aligned} \\] <p>donde NDC = Normalized Device Coordinates (van de -1 a +1).</p>"},{"location":"matematicas/#conversion-a-coordenadas-de-pantalla","title":"Conversi\u00f3n a Coordenadas de Pantalla","text":"<p>Para convertir a p\u00edxeles en pantalla:</p> \\[ \\begin{aligned} x_{\\text{screen}} &amp;= f_x \\cdot \\frac{x}{z} + c_x \\\\ y_{\\text{screen}} &amp;= c_y - f_y \\cdot \\frac{y}{z} \\end{aligned} \\] <p>donde:</p> <ul> <li>\\(f_x, f_y\\) = distancias focales en p\u00edxeles</li> <li>\\(c_x, c_y\\) = centro de proyecci\u00f3n (centro de pantalla)</li> <li>El signo negativo en \\(y\\) es porque en pantalla Y crece hacia abajo</li> </ul>"},{"location":"matematicas/#calculo-de-la-distancia-focal","title":"C\u00e1lculo de la Distancia Focal","text":"<p>Dado un campo de visi\u00f3n (FOV) en grados:</p> \\[ f_y = \\frac{h/2}{\\tan(\\text{FOV}/2)} \\] <p>donde \\(h\\) es la altura de la pantalla en p\u00edxeles.</p> <p>Ejemplo num\u00e9rico:</p> <p>Para FOV = 60\u00b0, altura = 580px:</p> \\[ f_y = \\frac{290}{\\tan(30\u00b0)} = \\frac{290}{0.577} \\approx 502 \\text{ p\u00edxeles} \\]"},{"location":"matematicas/#near-y-far-planes","title":"Near y Far Planes","text":"<p>Se define un near plane (\\(z_{\\text{near}}\\)) y opcionalmente un far plane (\\(z_{\\text{far}}\\)):</p> <ul> <li>Geometr\u00eda con \\(z &lt; z_{\\text{near}}\\) se descarta (detr\u00e1s de la c\u00e1mara)</li> <li>Geometr\u00eda con \\(z &gt; z_{\\text{far}}\\) se descarta (muy lejos)</li> </ul> <p>En este rasterizador: \\(z_{\\text{near}} = 0.001\\), sin far clipping.</p>"},{"location":"matematicas/#matriz-de-proyeccion-en-perspectiva","title":"Matriz de Proyecci\u00f3n en Perspectiva","text":"<p>La forma matricial completa (no usada directamente en el c\u00f3digo):</p> \\[ P = \\begin{pmatrix} \\frac{f_x}{a} &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; f_y &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; \\frac{f+n}{n-f} &amp; \\frac{2fn}{n-f} \\\\ 0 &amp; 0 &amp; -1 &amp; 0 \\end{pmatrix} \\] <p>donde \\(a\\) = aspect ratio, \\(f\\) = far, \\(n\\) = near.</p>"},{"location":"matematicas/#coordenadas-baricentricas","title":"Coordenadas Baric\u00e9ntricas","text":"<p>Las coordenadas baric\u00e9ntricas permiten expresar cualquier punto dentro de un tri\u00e1ngulo como combinaci\u00f3n lineal de sus v\u00e9rtices.</p>"},{"location":"matematicas/#definicion","title":"Definici\u00f3n","text":"<p>Para un tri\u00e1ngulo con v\u00e9rtices \\(\\mathbf{v}_1, \\mathbf{v}_2, \\mathbf{v}_3\\), cualquier punto \\(\\mathbf{p}\\) se expresa como:</p> \\[ \\mathbf{p} = \\lambda_1 \\mathbf{v}_1 + \\lambda_2 \\mathbf{v}_2 + \\lambda_3 \\mathbf{v}_3 \\] <p>donde \\(\\lambda_1 + \\lambda_2 + \\lambda_3 = 1\\) y \\(\\lambda_i \\geq 0\\) para puntos dentro del tri\u00e1ngulo.</p>"},{"location":"matematicas/#interpretacion-geometrica","title":"Interpretaci\u00f3n Geom\u00e9trica","text":"\\[ \\lambda_i = \\frac{\\text{\u00c1rea del subtri\u00e1ngulo opuesto a } \\mathbf{v}_i}{\\text{\u00c1rea total del tri\u00e1ngulo}} \\]"},{"location":"matematicas/#calculo-mediante-edge-function","title":"C\u00e1lculo mediante Edge Function","text":"<p>La edge function es el producto cruz 2D:</p> \\[ E(\\mathbf{p}_0, \\mathbf{p}_1, \\mathbf{p}) = (p_x - p_{0x})(p_{1y} - p_{0y}) - (p_y - p_{0y})(p_{1x} - p_{0x}) \\] <p>Interpretaci\u00f3n:</p> <ul> <li>\\(E &gt; 0\\): \\(\\mathbf{p}\\) est\u00e1 a la izquierda de la arista \\(\\mathbf{p}_0 \\to \\mathbf{p}_1\\)</li> <li>\\(E &lt; 0\\): \\(\\mathbf{p}\\) est\u00e1 a la derecha</li> <li>\\(E = 0\\): \\(\\mathbf{p}\\) est\u00e1 sobre la arista</li> </ul>"},{"location":"matematicas/#formulas-de-coordenadas-baricentricas","title":"F\u00f3rmulas de Coordenadas Baric\u00e9ntricas","text":"<p>Dado un tri\u00e1ngulo \\((\\mathbf{v}_1, \\mathbf{v}_2, \\mathbf{v}_3)\\) y un punto \\(\\mathbf{p}\\):</p> \\[ \\begin{aligned} A &amp;= E(\\mathbf{v}_1, \\mathbf{v}_2, \\mathbf{v}_3) \\quad \\text{(doble del \u00e1rea)} \\\\ \\lambda_1 &amp;= \\frac{E(\\mathbf{v}_2, \\mathbf{v}_3, \\mathbf{p})}{A} \\\\ \\lambda_2 &amp;= \\frac{E(\\mathbf{v}_3, \\mathbf{v}_1, \\mathbf{p})}{A} \\\\ \\lambda_3 &amp;= 1 - \\lambda_1 - \\lambda_2 \\end{aligned} \\]"},{"location":"matematicas/#test-de-inclusion","title":"Test de Inclusi\u00f3n","text":"<p>Un punto \\(\\mathbf{p}\\) est\u00e1 dentro del tri\u00e1ngulo si y solo si:</p> \\[ \\lambda_1 \\geq 0 \\quad \\land \\quad \\lambda_2 \\geq 0 \\quad \\land \\quad \\lambda_3 \\geq 0 \\]"},{"location":"matematicas/#interpolacion-de-atributos","title":"Interpolaci\u00f3n de Atributos","text":"<p>Para interpolar cualquier atributo (color, profundidad, coordenadas de textura):</p> \\[ u(\\mathbf{p}) = \\lambda_1 u_1 + \\lambda_2 u_2 + \\lambda_3 u_3 \\] <p>\u26a0\ufe0f Importante: Esta f\u00f3rmula es correcta en 3D, pero en 2D (despu\u00e9s de proyecci\u00f3n) requiere correcci\u00f3n de perspectiva.</p>"},{"location":"matematicas/#interpolacion-perspective-correct","title":"Interpolaci\u00f3n Perspective-Correct","text":""},{"location":"matematicas/#el-problema","title":"El Problema","text":"<p>Despu\u00e9s de la proyecci\u00f3n en perspectiva, la interpolaci\u00f3n lineal en espacio de pantalla no corresponde a interpolaci\u00f3n lineal en espacio 3D.</p> <p>Ejemplo visual: <pre><code>En 3D: Puntos equiespaciados en una l\u00ednea\n   o-----o-----o-----o\n\nDespu\u00e9s de proyecci\u00f3n:\n   o----o---o--o  (no equiespaciados!)\n</code></pre></p>"},{"location":"matematicas/#la-solucion","title":"La Soluci\u00f3n","text":"<p>Para interpolar correctamente un atributo \\(u\\) despu\u00e9s de la proyecci\u00f3n:</p> \\[ \\frac{1}{z_p} = \\lambda_1 \\frac{1}{z_1} + \\lambda_2 \\frac{1}{z_2} + \\lambda_3 \\frac{1}{z_3} \\] \\[ u_p = \\frac{\\lambda_1 \\frac{u_1}{z_1} + \\lambda_2 \\frac{u_2}{z_2} + \\lambda_3 \\frac{u_3}{z_3}}{\\frac{1}{z_p}} \\]"},{"location":"matematicas/#simplificacion-para-profundidad","title":"Simplificaci\u00f3n para Profundidad","text":"<p>Para interpolar solo la profundidad \\(z\\):</p> \\[ \\begin{aligned} \\frac{1}{z_p} &amp;= \\lambda_1 \\frac{1}{z_1} + \\lambda_2 \\frac{1}{z_2} + \\lambda_3 \\frac{1}{z_3} \\\\ z_p &amp;= \\frac{1}{\\frac{1}{z_p}} \\end{aligned} \\]"},{"location":"matematicas/#demostracion-matematica","title":"Demostraci\u00f3n Matem\u00e1tica","text":"<p>La proyecci\u00f3n divide por \\(z\\):</p> \\[ x_{\\text{screen}} = \\frac{f_x \\cdot x}{z} + c_x \\] <p>Esto introduce una transformaci\u00f3n no-lineal (hiperb\u00f3lica) en el espacio.</p> <p>Para recuperar la interpolaci\u00f3n lineal original en 3D, debemos interpolar \\(1/z\\) (cantidad lineal en espacio de proyecci\u00f3n) en lugar de \\(z\\) directamente.</p> <p>Proof sketch:</p> <ol> <li>En espacio 3D (antes de proyecci\u00f3n): \\(u\\) var\u00eda linealmente</li> <li>Proyecci\u00f3n: \\(x' = x/z\\) (transformaci\u00f3n no-lineal)</li> <li>En espacio 2D: \\(u/z\\) var\u00eda linealmente</li> <li>Para recuperar \\(u\\): multiplicar por \\(z\\)</li> </ol>"},{"location":"matematicas/#ejemplo-numerico","title":"Ejemplo Num\u00e9rico","text":"<pre><code>Tri\u00e1ngulo con v\u00e9rtices:\n  v1 = (0, 0, 1), u1 = 0.0\n  v2 = (1, 0, 2), u2 = 1.0\n  v3 = (0, 1, 1), u3 = 0.5\n\nPunto p con coordenadas baric\u00e9ntricas:\n  \u03bb1 = 0.25, \u03bb2 = 0.50, \u03bb3 = 0.25\n\nInterpolaci\u00f3n incorrecta (lineal):\n  u_wrong = 0.25\u00d70.0 + 0.50\u00d71.0 + 0.25\u00d70.5 = 0.625\n\nInterpolaci\u00f3n correcta (perspective-correct):\n  1/z_p = 0.25\u00d7(1/1) + 0.50\u00d7(1/2) + 0.25\u00d7(1/1)\n       = 0.25 + 0.25 + 0.25 = 0.75\n  z_p = 1/0.75 = 1.333\n\n  u_correct = (0.25\u00d70.0/1 + 0.50\u00d71.0/2 + 0.25\u00d70.5/1) \u00d7 1.333\n           = (0 + 0.25 + 0.125) \u00d7 1.333 = 0.5\n</code></pre>"},{"location":"matematicas/#z-buffering","title":"Z-Buffering","text":"<p>El z-buffer (o depth buffer) es una t\u00e9cnica para resolver el problema de visibilidad: determinar qu\u00e9 superficies est\u00e1n frente a otras.</p>"},{"location":"matematicas/#problema-de-visibilidad","title":"Problema de Visibilidad","text":"<p>Sin un mecanismo de visibilidad, tri\u00e1ngulos dibujados m\u00e1s tarde sobrescriben los anteriores, sin importar su profundidad:</p> <pre><code>Incorrecto (sin z-buffer):\n  Dibujar tri\u00e1ngulo lejano \u2192 OK\n  Dibujar tri\u00e1ngulo cercano \u2192 OK\n  Dibujar tri\u00e1ngulo lejano \u2192 \u00a1Sobrescribe el cercano! \u274c\n</code></pre>"},{"location":"matematicas/#algoritmo-z-buffer","title":"Algoritmo Z-Buffer","text":"<p>Inicializaci\u00f3n: <pre><code>Para cada p\u00edxel (x, y):\n  zbuffer[x, y] = \u221e\n  color[x, y] = color_fondo\n</code></pre></p> <p>Para cada tri\u00e1ngulo: <pre><code>Para cada p\u00edxel (x, y) cubierto por el tri\u00e1ngulo:\n  z = profundidad interpolada en (x, y)\n\n  if z &lt; zbuffer[x, y]:\n    zbuffer[x, y] = z\n    color[x, y] = color_tri\u00e1ngulo\n</code></pre></p>"},{"location":"matematicas/#formula-matematica","title":"F\u00f3rmula Matem\u00e1tica","text":"<p>Para un p\u00edxel \\((x, y)\\) y un conjunto de tri\u00e1ngulos \\(\\{T_1, T_2, \\ldots, T_n\\}\\):</p> \\[ \\text{color}(x, y) = \\text{color}(T_i) \\quad \\text{donde} \\quad i = \\arg\\min_j z_j(x, y) \\] <p>Es decir, se dibuja el color del tri\u00e1ngulo con menor profundidad (m\u00e1s cercano).</p>"},{"location":"matematicas/#ventajas","title":"Ventajas","text":"<p>\u2713 No requiere ordenamiento: Los tri\u00e1ngulos pueden procesarse en cualquier orden \u2713 Maneja escenas complejas: Funciona con intersecciones arbitrarias de geometr\u00eda \u2713 Complejidad lineal: \\(O(n)\\) en el n\u00famero de tri\u00e1ngulos \u2713 F\u00e1cil de implementar: Algoritmo simple y robusto</p>"},{"location":"matematicas/#desventajas","title":"Desventajas","text":"<p>\u2717 Memoria adicional: Requiere un buffer completo (\\(W \\times H\\) valores) \u2717 No maneja transparencia: Solo un fragmento por p\u00edxel (el m\u00e1s cercano) \u2717 Z-fighting: Problemas de precisi\u00f3n cuando dos superficies est\u00e1n muy cerca \u2717 Overdraw: P\u00edxeles pueden dibujarse m\u00faltiples veces (desperdicio)</p>"},{"location":"matematicas/#z-fighting","title":"Z-Fighting","text":"<p>Ocurre cuando dos tri\u00e1ngulos tienen profundidades muy similares:</p> \\[ |z_1 - z_2| &lt; \\epsilon_{\\text{float}} \\] <p>Soluciones:</p> <ol> <li>Usar mayor precisi\u00f3n (float64 en lugar de float32)</li> <li>Ajustar near/far planes para mejor distribuci\u00f3n de profundidad</li> <li>Offset de pol\u00edgonos (polygon offset)</li> <li>Usar logarithmic depth buffer</li> </ol>"},{"location":"matematicas/#comparacion-con-painters-algorithm","title":"Comparaci\u00f3n con Painter's Algorithm","text":"<p>Painter's Algorithm: Ordenar tri\u00e1ngulos por profundidad y dibujar de atr\u00e1s hacia adelante.</p> Aspecto Z-Buffer Painter's Ordenamiento No requiere Requiere \\(O(n \\log n)\\) Intersecciones Maneja correctamente Falla con ciclos Memoria \\(O(W \\times H)\\) \\(O(1)\\) Transparencia No soporta bien Funciona bien"},{"location":"matematicas/#optimizaciones","title":"Optimizaciones","text":"<p>Early Z-Test (no implementado aqu\u00ed): - Probar z-buffer antes de calcular color - Ahorra c\u00e1lculos de shading para p\u00edxeles ocultos</p> <p>Hierarchical Z-Buffer: - Mantener mipmap de valores m\u00ednimos de z - Descartar tri\u00e1ngulos completos si est\u00e1n detr\u00e1s</p> <p>Z-Prepass: - Primer pass: solo escribir profundidad - Segundo pass: dibujar color (solo p\u00edxeles visibles)</p>"},{"location":"matematicas/#pipeline-completo","title":"Pipeline Completo","text":"<p>Resumen del flujo matem\u00e1tico completo:</p> <pre><code>1. ESPACIO DE MODELO\n   v_model = (x, y, z)\n\n   \u2193 [Rotaci\u00f3n + Traslaci\u00f3n]\n\n2. ESPACIO MUNDIAL\n   v_world = R_model \u00d7 v_model + t_model\n\n   \u2193 [Traslaci\u00f3n de c\u00e1mara + Rotaci\u00f3n inversa]\n\n3. ESPACIO DE C\u00c1MARA\n   v_camera = R_cam^T \u00d7 (v_world - p_cam)\n\n   \u2193 [Proyecci\u00f3n en perspectiva]\n\n4. ESPACIO DE PANTALLA (2D + profundidad)\n   x_screen = f_x \u00d7 (v_camera.x / v_camera.z) + c_x\n   y_screen = c_y - f_y \u00d7 (v_camera.y / v_camera.z)\n   z_depth = v_camera.z\n\n   \u2193 [Triangulaci\u00f3n + Clipping]\n\n5. TRI\u00c1NGULOS V\u00c1LIDOS\n   {(v1, v2, v3) | z_i &gt; near, \u00e1rea &gt; \u03b5}\n\n   \u2193 [Rasterizaci\u00f3n]\n\n6. P\u00cdXELES CON ATRIBUTOS\n   Para cada p\u00edxel en tri\u00e1ngulo:\n     - Coordenadas baric\u00e9ntricas (\u03bb1, \u03bb2, \u03bb3)\n     - Profundidad (perspective-correct)\n     - Test de inclusi\u00f3n\n     - Z-buffer test\n\n   \u2193 [Presentaci\u00f3n]\n\n7. FRAME BUFFER \u2192 PANTALLA\n</code></pre> <p>Cada etapa aplica transformaciones matem\u00e1ticas espec\u00edficas que, en conjunto, crean la ilusi\u00f3n de un mundo 3D proyectado en una pantalla 2D.</p>"},{"location":"matematicas/#referencias","title":"Referencias","text":"<ol> <li>Real-Time Rendering (4th Edition) - Akenine-M\u00f6ller et al.</li> <li>Computer Graphics: Principles and Practice (3rd Edition) - Hughes et al.</li> <li>Fundamentals of Computer Graphics (5th Edition) - Marschner &amp; Shirley</li> <li>Scratchapixel: https://www.scratchapixel.com/</li> <li>learnopengl.com: https://learnopengl.com/</li> </ol> <p>\ud83d\udcdd Nota: Todas las f\u00f3rmulas en este documento est\u00e1n implementadas en el rasterizador. Puedes encontrar el c\u00f3digo correspondiente en <code>lua/vectors.lua</code> y <code>lua/main.lua</code>.</p>"}]}